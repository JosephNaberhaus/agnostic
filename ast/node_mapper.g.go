// Code generated by tool/code_generator. DO NOT EDIT.

package ast

import "fmt"

// Node is the interface that everything in this package implements
type Node interface {
	// isNode is only a type-guard to limit what can be used as a Node.
	isNode()
}

func (l LiteralInt32) isNode() {}

func (l LiteralString) isNode() {}

func (f FieldDef) isNode() {}

func (a ArgumentDef) isNode() {}

func (m MethodDef) isNode() {}

func (m ModelDef) isNode() {}

func (p Property) isNode() {}

func (t This) isNode() {}

func (m Module) isNode() {}

func (u UnaryOperator) isNode() {}

func (u UnaryOperation) isNode() {}

func (b BinaryOperator) isNode() {}

func (b BinaryOperation) isNode() {}

func (a Assignment) isNode() {}

func (i If) isNode() {}

func (e ElseIf) isNode() {}

func (e Else) isNode() {}

func (c Conditional) isNode() {}

func (m Model) isNode() {}

func (p Primitive) isNode() {}

type NodeMapper[T any] interface {
	MapLiteralInt32(original LiteralInt32) (T, error)

	MapLiteralString(original LiteralString) (T, error)

	MapFieldDef(original FieldDef) (T, error)

	MapArgumentDef(original ArgumentDef) (T, error)

	MapMethodDef(original MethodDef) (T, error)

	MapModelDef(original ModelDef) (T, error)

	MapProperty(original Property) (T, error)

	MapThis(original This) (T, error)

	MapModule(original Module) (T, error)

	MapUnaryOperator(original UnaryOperator) (T, error)

	MapUnaryOperation(original UnaryOperation) (T, error)

	MapBinaryOperator(original BinaryOperator) (T, error)

	MapBinaryOperation(original BinaryOperation) (T, error)

	MapAssignment(original Assignment) (T, error)

	MapIf(original If) (T, error)

	MapElseIf(original ElseIf) (T, error)

	MapElse(original Else) (T, error)

	MapConditional(original Conditional) (T, error)

	MapModel(original Model) (T, error)

	MapPrimitive(original Primitive) (T, error)
}

func MapNode[T any](node Node, mapper NodeMapper[T]) (T, error) {
	switch value := node.(type) {

	case LiteralInt32:
		return mapper.MapLiteralInt32(value)

	case LiteralString:
		return mapper.MapLiteralString(value)

	case FieldDef:
		return mapper.MapFieldDef(value)

	case ArgumentDef:
		return mapper.MapArgumentDef(value)

	case MethodDef:
		return mapper.MapMethodDef(value)

	case ModelDef:
		return mapper.MapModelDef(value)

	case Property:
		return mapper.MapProperty(value)

	case This:
		return mapper.MapThis(value)

	case Module:
		return mapper.MapModule(value)

	case UnaryOperator:
		return mapper.MapUnaryOperator(value)

	case UnaryOperation:
		return mapper.MapUnaryOperation(value)

	case BinaryOperator:
		return mapper.MapBinaryOperator(value)

	case BinaryOperation:
		return mapper.MapBinaryOperation(value)

	case Assignment:
		return mapper.MapAssignment(value)

	case If:
		return mapper.MapIf(value)

	case ElseIf:
		return mapper.MapElseIf(value)

	case Else:
		return mapper.MapElse(value)

	case Conditional:
		return mapper.MapConditional(value)

	case Model:
		return mapper.MapModel(value)

	case Primitive:
		return mapper.MapPrimitive(value)

	default:
		var zero T
		return zero, fmt.Errorf("unknown Node: %T", node)
	}
}

type AssignableMapper[T any] interface {
	MapProperty(original Property) (T, error)
}

func MapAssignable[T any](nodeType Assignable, mapper AssignableMapper[T]) (T, error) {
	switch value := nodeType.(type) {

	case Property:
		return mapper.MapProperty(value)

	default:
		var zero T
		return zero, fmt.Errorf("unknown Assignable: %T", nodeType)
	}
}

type DefinitionMapper[T any] interface {
	MapFieldDef(original FieldDef) (T, error)

	MapArgumentDef(original ArgumentDef) (T, error)
}

func MapDefinition[T any](nodeType Definition, mapper DefinitionMapper[T]) (T, error) {
	switch value := nodeType.(type) {

	case FieldDef:
		return mapper.MapFieldDef(value)

	case ArgumentDef:
		return mapper.MapArgumentDef(value)

	default:
		var zero T
		return zero, fmt.Errorf("unknown Definition: %T", nodeType)
	}
}

type StatementMapper[T any] interface {
	MapAssignment(original Assignment) (T, error)

	MapConditional(original Conditional) (T, error)
}

func MapStatement[T any](nodeType Statement, mapper StatementMapper[T]) (T, error) {
	switch value := nodeType.(type) {

	case Assignment:
		return mapper.MapAssignment(value)

	case Conditional:
		return mapper.MapConditional(value)

	default:
		var zero T
		return zero, fmt.Errorf("unknown Statement: %T", nodeType)
	}
}

type TypeMapper[T any] interface {
	MapModel(original Model) (T, error)

	MapPrimitive(original Primitive) (T, error)
}

func MapType[T any](nodeType Type, mapper TypeMapper[T]) (T, error) {
	switch value := nodeType.(type) {

	case Model:
		return mapper.MapModel(value)

	case Primitive:
		return mapper.MapPrimitive(value)

	default:
		var zero T
		return zero, fmt.Errorf("unknown Type: %T", nodeType)
	}
}

type ValueMapper[T any] interface {
	MapLiteralInt32(original LiteralInt32) (T, error)

	MapLiteralString(original LiteralString) (T, error)

	MapProperty(original Property) (T, error)

	MapThis(original This) (T, error)

	MapUnaryOperation(original UnaryOperation) (T, error)

	MapBinaryOperation(original BinaryOperation) (T, error)
}

func MapValue[T any](nodeType Value, mapper ValueMapper[T]) (T, error) {
	switch value := nodeType.(type) {

	case LiteralInt32:
		return mapper.MapLiteralInt32(value)

	case LiteralString:
		return mapper.MapLiteralString(value)

	case Property:
		return mapper.MapProperty(value)

	case This:
		return mapper.MapThis(value)

	case UnaryOperation:
		return mapper.MapUnaryOperation(value)

	case BinaryOperation:
		return mapper.MapBinaryOperation(value)

	default:
		var zero T
		return zero, fmt.Errorf("unknown Value: %T", nodeType)
	}
}
