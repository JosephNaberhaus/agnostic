// Code generated by tool/code_generator. DO NOT EDIT.

package code

import "fmt"

// Node is the interface that everything in this package implements
type Node interface {
	// isNode is only a type-guard to limit what can be used as a Node.
	isNode()
}

func (f *Function) isNode() {}

func (f *FunctionProperty) isNode() {}

func (l *LiteralInt) isNode() {}

func (l *LiteralString) isNode() {}

func (f *FieldDef) isNode() {}

func (a *ArgumentDef) isNode() {}

func (m *MethodDef) isNode() {}

func (m *ModelDef) isNode() {}

func (v *Variable) isNode() {}

func (p *Property) isNode() {}

func (m *Module) isNode() {}

func (f *FunctionDef) isNode() {}

func (u UnaryOperator) isNode() {}

func (u *UnaryOperation) isNode() {}

func (b BinaryOperator) isNode() {}

func (b *BinaryOperation) isNode() {}

func (a *Assignment) isNode() {}

func (i *If) isNode() {}

func (e *ElseIf) isNode() {}

func (e *Else) isNode() {}

func (c *Conditional) isNode() {}

func (r *Return) isNode() {}

func (d *Declare) isNode() {}

func (m *Model) isNode() {}

func (p Primitive) isNode() {}

func (l *List) isNode() {}

func (m *Map) isNode() {}

func (c *Call) isNode() {}

func (l *Lookup) isNode() {}

func (n *New) isNode() {}

type NodeMapper[T any] interface {
	MapFunction(original *Function) (T, error)

	MapFunctionProperty(original *FunctionProperty) (T, error)

	MapLiteralInt(original *LiteralInt) (T, error)

	MapLiteralString(original *LiteralString) (T, error)

	MapFieldDef(original *FieldDef) (T, error)

	MapArgumentDef(original *ArgumentDef) (T, error)

	MapMethodDef(original *MethodDef) (T, error)

	MapModelDef(original *ModelDef) (T, error)

	MapVariable(original *Variable) (T, error)

	MapProperty(original *Property) (T, error)

	MapModule(original *Module) (T, error)

	MapFunctionDef(original *FunctionDef) (T, error)

	MapUnaryOperator(original UnaryOperator) (T, error)

	MapUnaryOperation(original *UnaryOperation) (T, error)

	MapBinaryOperator(original BinaryOperator) (T, error)

	MapBinaryOperation(original *BinaryOperation) (T, error)

	MapAssignment(original *Assignment) (T, error)

	MapIf(original *If) (T, error)

	MapElseIf(original *ElseIf) (T, error)

	MapElse(original *Else) (T, error)

	MapConditional(original *Conditional) (T, error)

	MapReturn(original *Return) (T, error)

	MapDeclare(original *Declare) (T, error)

	MapModel(original *Model) (T, error)

	MapPrimitive(original Primitive) (T, error)

	MapList(original *List) (T, error)

	MapMap(original *Map) (T, error)

	MapCall(original *Call) (T, error)

	MapLookup(original *Lookup) (T, error)

	MapNew(original *New) (T, error)
}

func MapNode[T any](node Node, mapper NodeMapper[T]) (T, error) {
	switch value := node.(type) {

	case *Function:
		return mapper.MapFunction(value)

	case *FunctionProperty:
		return mapper.MapFunctionProperty(value)

	case *LiteralInt:
		return mapper.MapLiteralInt(value)

	case *LiteralString:
		return mapper.MapLiteralString(value)

	case *FieldDef:
		return mapper.MapFieldDef(value)

	case *ArgumentDef:
		return mapper.MapArgumentDef(value)

	case *MethodDef:
		return mapper.MapMethodDef(value)

	case *ModelDef:
		return mapper.MapModelDef(value)

	case *Variable:
		return mapper.MapVariable(value)

	case *Property:
		return mapper.MapProperty(value)

	case *Module:
		return mapper.MapModule(value)

	case *FunctionDef:
		return mapper.MapFunctionDef(value)

	case UnaryOperator:
		return mapper.MapUnaryOperator(value)

	case *UnaryOperation:
		return mapper.MapUnaryOperation(value)

	case BinaryOperator:
		return mapper.MapBinaryOperator(value)

	case *BinaryOperation:
		return mapper.MapBinaryOperation(value)

	case *Assignment:
		return mapper.MapAssignment(value)

	case *If:
		return mapper.MapIf(value)

	case *ElseIf:
		return mapper.MapElseIf(value)

	case *Else:
		return mapper.MapElse(value)

	case *Conditional:
		return mapper.MapConditional(value)

	case *Return:
		return mapper.MapReturn(value)

	case *Declare:
		return mapper.MapDeclare(value)

	case *Model:
		return mapper.MapModel(value)

	case Primitive:
		return mapper.MapPrimitive(value)

	case *List:
		return mapper.MapList(value)

	case *Map:
		return mapper.MapMap(value)

	case *Call:
		return mapper.MapCall(value)

	case *Lookup:
		return mapper.MapLookup(value)

	case *New:
		return mapper.MapNew(value)

	default:
		var zero T
		return zero, fmt.Errorf("unknown Node: %T", node)
	}
}

func MapNodes[T any, V Node](nodes []V, mapper NodeMapper[T]) ([]T, error) {
	var resultNodes []T
	for _, node := range nodes {
		resultNode, err := MapNode(node, mapper)
		if err != nil {
			return nil, err
		}

		resultNodes = append(resultNodes, resultNode)
	}

	return resultNodes, nil
}

type CallableMapper[T any] interface {
	MapFunction(original *Function) (T, error)

	MapFunctionProperty(original *FunctionProperty) (T, error)
}

func MapCallable[T any](nodeType Callable, mapper CallableMapper[T]) (T, error) {
	switch value := nodeType.(type) {

	case *Function:
		return mapper.MapFunction(value)

	case *FunctionProperty:
		return mapper.MapFunctionProperty(value)

	default:
		var zero T
		return zero, fmt.Errorf("unknown Callable: %T", nodeType)
	}
}

type DefinitionMapper[T any] interface {
	MapFieldDef(original *FieldDef) (T, error)

	MapArgumentDef(original *ArgumentDef) (T, error)

	MapDeclare(original *Declare) (T, error)
}

func MapDefinition[T any](nodeType Definition, mapper DefinitionMapper[T]) (T, error) {
	switch value := nodeType.(type) {

	case *FieldDef:
		return mapper.MapFieldDef(value)

	case *ArgumentDef:
		return mapper.MapArgumentDef(value)

	case *Declare:
		return mapper.MapDeclare(value)

	default:
		var zero T
		return zero, fmt.Errorf("unknown Definition: %T", nodeType)
	}
}

type StatementMapper[T any] interface {
	MapAssignment(original *Assignment) (T, error)

	MapConditional(original *Conditional) (T, error)

	MapReturn(original *Return) (T, error)

	MapDeclare(original *Declare) (T, error)
}

func MapStatement[T any](nodeType Statement, mapper StatementMapper[T]) (T, error) {
	switch value := nodeType.(type) {

	case *Assignment:
		return mapper.MapAssignment(value)

	case *Conditional:
		return mapper.MapConditional(value)

	case *Return:
		return mapper.MapReturn(value)

	case *Declare:
		return mapper.MapDeclare(value)

	default:
		var zero T
		return zero, fmt.Errorf("unknown Statement: %T", nodeType)
	}
}

type TypeMapper[T any] interface {
	MapModel(original *Model) (T, error)

	MapPrimitive(original Primitive) (T, error)

	MapList(original *List) (T, error)

	MapMap(original *Map) (T, error)
}

func MapType[T any](nodeType Type, mapper TypeMapper[T]) (T, error) {
	switch value := nodeType.(type) {

	case *Model:
		return mapper.MapModel(value)

	case Primitive:
		return mapper.MapPrimitive(value)

	case *List:
		return mapper.MapList(value)

	case *Map:
		return mapper.MapMap(value)

	default:
		var zero T
		return zero, fmt.Errorf("unknown Type: %T", nodeType)
	}
}

type ValueMapper[T any] interface {
	MapLiteralInt(original *LiteralInt) (T, error)

	MapLiteralString(original *LiteralString) (T, error)

	MapVariable(original *Variable) (T, error)

	MapProperty(original *Property) (T, error)

	MapUnaryOperation(original *UnaryOperation) (T, error)

	MapBinaryOperation(original *BinaryOperation) (T, error)

	MapCall(original *Call) (T, error)

	MapLookup(original *Lookup) (T, error)

	MapNew(original *New) (T, error)
}

func MapValue[T any](nodeType Value, mapper ValueMapper[T]) (T, error) {
	switch value := nodeType.(type) {

	case *LiteralInt:
		return mapper.MapLiteralInt(value)

	case *LiteralString:
		return mapper.MapLiteralString(value)

	case *Variable:
		return mapper.MapVariable(value)

	case *Property:
		return mapper.MapProperty(value)

	case *UnaryOperation:
		return mapper.MapUnaryOperation(value)

	case *BinaryOperation:
		return mapper.MapBinaryOperation(value)

	case *Call:
		return mapper.MapCall(value)

	case *Lookup:
		return mapper.MapLookup(value)

	case *New:
		return mapper.MapNew(value)

	default:
		var zero T
		return zero, fmt.Errorf("unknown Value: %T", nodeType)
	}
}
