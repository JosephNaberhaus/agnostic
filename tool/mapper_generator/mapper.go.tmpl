// Code generated by tool/code_generator. DO NOT EDIT.

package {{ .PackageName }}

import "fmt"

// Node is the interface that everything in this package implements
type Node interface {
    // isNode is only a type-guard to limit what can be used as a Node.
    isNode()
}

{{ range $node := $.Nodes }}
func ({{ GetReceiver $node.Name }} {{ if and $.UsePointersForStructs $node.IsStruct }}*{{ end }}{{ $node.Name }}) isNode() {}
{{ end }}

type NodeMapper[T any] interface {
{{ range $node := $.Nodes }}
    Map{{ $node.Name }}(original {{ if and $.UsePointersForStructs $node.IsStruct }}*{{ end }}{{ $node.Name }}) (T, error)
{{ end }}
}

func MapNode[T any](node Node, mapper NodeMapper[T]) (T, error) {
    switch value := node.(type) {
    {{ range $node := $.Nodes }}
    case {{ if and $.UsePointersForStructs $node.IsStruct }}*{{ end }}{{ $node.Name }}:
        return mapper.Map{{ $node.Name }}(value)
    {{ end }}
    default:
        var zero T
        return zero, fmt.Errorf("unknown Node: %T", node)
    }
}

func MapNodes[T any, V Node](nodes []V, mapper NodeMapper[T]) ([]T, error) {
	var resultNodes []T
	for _, node := range nodes {
		resultNode, err := MapNode(node, mapper)
		if err != nil {
			return nil, err
		}

		resultNodes = append(resultNodes, resultNode)
	}

	return resultNodes, nil
}

{{ range $nodeType, $implementations := $.NodeTypeImplementations }}
type {{ $nodeType.Name }}Mapper[T any] interface {
{{ range $implementation := $implementations }}
    Map{{ RemovePointer $implementation }}(original {{ $implementation }}) (T, error)
{{ end }}
}

func Map{{ $nodeType.Name }}[T any](nodeType {{ $nodeType.Name }}, mapper {{ $nodeType.Name }}Mapper[T]) (T, error) {
    switch value := nodeType.(type) {
    {{ range $implementation := $implementations }}
    case {{ $implementation }}:
        return mapper.Map{{ RemovePointer $implementation }}(value)
    {{ end }}
    default:
        var zero T
        return zero, fmt.Errorf("unknown {{ $nodeType.Name }}: %T", nodeType)
    }
}

{{ end }}
