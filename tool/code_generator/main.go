package main

import (
	"fmt"
	"go/ast"
	"go/parser"
	"go/printer"
	"go/token"
	"go/types"
	"log"
	"os"
	"path/filepath"
	"strings"
)

const fileHeader = "// Code generated by tool/code_generator. DO NOT EDIT."

// TODO: Change these to be flags
const sourceDirPath = "../ast"
const outputPath = "."

func main() {
	err := deleteGeneratedFiles(outputPath)
	if err != nil {
		log.Fatalf("failed to delete generated files: %s", err.Error())
	}

	sourcePaths, err := getSourcePathsToGenerate()
	if err != nil {
		log.Fatalf("failed to get source paths: %s", err.Error())
	}

	files, err := parseFiles(sourcePaths)
	if err != nil {
		log.Fatalf("failed to parse files: %s", err.Error())
	}

	err = updatePackageNames(files)
	if err != nil {
		log.Fatalf("failed to update package names: %s", err.Error())
	}

	structDefs, err := findPublicStructs(files)
	if err != nil {
		log.Fatalf("failed to find public structs: %s", err.Error())
	}
	structNameSet := createStructNameSet(structDefs)

	for _, structDef := range structDefs {
		updateStructFieldsToPointers(structDef.structType, structNameSet)
		addMetadataField(structDef)
	}

	updateReceiversToPointers(files, structNameSet)

	err = outputFiles(files)
	if err != nil {
		log.Fatalf("failed to output files: %s", err.Error())
	}
}

func deleteGeneratedFiles(dirPath string) error {
	files, err := os.ReadDir(dirPath)
	if err != nil {
		return fmt.Errorf("deleteGeneratedFiles failed to read dir \"%s\": %w", dirPath, err)
	}

	for _, file := range files {
		if strings.HasSuffix(file.Name(), ".g.go") {
			filePath := filepath.Join(dirPath, file.Name())
			err = os.Remove(filePath)
			if err != nil {
				return fmt.Errorf("deleteGeneratedFiles failed to remove file \"%s\": %w", filePath, err)
			}
		}
	}

	return nil
}

func getSourcePathsToGenerate() ([]string, error) {
	sources, err := os.ReadDir(sourceDirPath)
	if err != nil {
		return nil, fmt.Errorf("getSourcePathsToGenerate failed to read dir \"%s\": %w", sourceDirPath, err)
	}

	var sourcePaths []string
	for _, source := range sources {
		// Skip anything that isn't a Go source file.
		if filepath.Ext(source.Name()) != ".go" {
			continue
		}

		// Skip generated files
		if strings.HasSuffix(source.Name(), ".g.go") {
			continue
		}

		sourcePaths = append(sourcePaths, filepath.Join(sourceDirPath, source.Name()))
	}

	return sourcePaths, nil
}

type sourceFile struct {
	path    string
	astFile *ast.File
}

type sourceFileSet struct {
	sourceFiles []sourceFile
	astFileSet  *token.FileSet
}

func parseFiles(sourcePaths []string) (sourceFileSet, error) {
	astFileSet := token.NewFileSet()

	var sourceFiles []sourceFile
	for _, sourcePath := range sourcePaths {
		file, err := parser.ParseFile(astFileSet, sourcePath, nil, parser.SkipObjectResolution)
		if err != nil {
			return sourceFileSet{}, fmt.Errorf("parseFiles failed to parse file \"%s\": %w", sourcePath, err)
		}

		sourceFiles = append(sourceFiles, sourceFile{
			path:    sourcePath,
			astFile: file,
		})
	}

	return sourceFileSet{
		sourceFiles: sourceFiles,
		astFileSet:  astFileSet,
	}, nil
}

// createPackageName creates a package name ast.Ident for a file in the given directory.
func createPackageName(dirPath string) (*ast.Ident, error) {
	wd, err := os.Getwd()
	if err != nil {
		return nil, fmt.Errorf("createPackageName failed to get the working directory: %w", err)
	}

	return &ast.Ident{
		Name: filepath.Base(filepath.Join(wd, dirPath)),
	}, nil
}

func updatePackageNames(sourceFileSet sourceFileSet) error {
	packageName, err := createPackageName(outputPath)
	if err != nil {
		return fmt.Errorf("updatePackageNames failed to create a package name: %w", err)
	}

	for _, sourceFile := range sourceFileSet.sourceFiles {
		sourceFile.astFile.Name = packageName
	}

	return nil
}

type structDef struct {
	name       string
	structType *ast.StructType
}

// getPublicStructs finds all of the public struct types in the file.
func findPublicStructs(sourceFileSet sourceFileSet) ([]structDef, error) {
	var structs []structDef
	for _, sourceFile := range sourceFileSet.sourceFiles {
		for _, decl := range sourceFile.astFile.Decls {
			if genDecl, ok := decl.(*ast.GenDecl); ok {
				for _, spec := range genDecl.Specs {
					if typeSpec, ok := spec.(*ast.TypeSpec); ok {
						if !token.IsExported(typeSpec.Name.String()) {
							continue
						}

						if structType, ok := typeSpec.Type.(*ast.StructType); ok {
							structs = append(structs, structDef{
								name:       typeSpec.Name.String(),
								structType: structType,
							})
						}
					}
				}
			}
		}
	}

	return structs, nil
}

func createStructNameSet(structDefs []structDef) map[string]struct{} {
	structNames := map[string]struct{}{}
	for _, structDef := range structDefs {
		structNames[structDef.name] = struct{}{}
	}

	return structNames
}

// updateTypeToPointer converts the type to use pointer semantics rather than value semantics.
func updateTypeToPointer(typeExpr ast.Expr, structNames map[string]struct{}) ast.Expr {
	typeName := types.ExprString(typeExpr)
	if sliceExpr, ok := typeExpr.(*ast.ArrayType); ok {
		sliceExpr.Elt = updateTypeToPointer(sliceExpr.Elt, structNames)
		return typeExpr
	} else if _, isStruct := structNames[typeName]; isStruct {
		return &ast.StarExpr{X: typeExpr}
	}

	return typeExpr
}

// changeFieldsToPointers converts all the fields in a struct to use pointer semantics rather than value semantics.
func updateStructFieldsToPointers(structType *ast.StructType, structNames map[string]struct{}) {
	if structType.Fields.List != nil {
		for _, field := range structType.Fields.List {
			field.Type = updateTypeToPointer(field.Type, structNames)
		}
	}
}

func updateReceiversToPointers(sourceFileSet sourceFileSet, structNames map[string]struct{}) {
	for _, file := range sourceFileSet.sourceFiles {
		for _, decl := range file.astFile.Decls {
			if funcDecl, ok := decl.(*ast.FuncDecl); ok {
				// Only update methods
				if funcDecl.Recv == nil {
					continue
				}

				funcDecl.Recv.List[0].Type = updateTypeToPointer(funcDecl.Recv.List[0].Type, structNames)
			}
		}
	}
}

// createMetaField creates the metadata field for a struct.
func createMetaField(structName string) *ast.Field {
	return &ast.Field{
		Type: &ast.Ident{
			NamePos: 0,
			Name:    structName + "Metadata",
			Obj:     nil,
		},
	}
}

// addMetadataField appends the metadata field to the given struct.
func addMetadataField(structDef structDef) {
	structDef.structType.Fields.List = append(structDef.structType.Fields.List, createMetaField(structDef.name))
}

func outputFiles(sourceFileSet sourceFileSet) error {
	for _, sourceFile := range sourceFileSet.sourceFiles {
		sourceFileName := filepath.Base(sourceFile.path)
		generatedFilename := strings.TrimSuffix(sourceFileName, filepath.Ext(sourceFileName)) + ".g.go"
		generatedFilepath := filepath.Join(outputPath, generatedFilename)
		outputFile, err := os.Create(generatedFilepath)
		defer outputFile.Close()
		if err != nil {
			return fmt.Errorf("generate failed to create output file \"%s\": %w", generatedFilename, err)
		}

		_, err = outputFile.WriteString(fileHeader + "\n\n")
		if err != nil {
			return fmt.Errorf("generate failed to write file header: %w", err)
		}

		err = printer.Fprint(outputFile, sourceFileSet.astFileSet, sourceFile.astFile)
		if err != nil {
			return fmt.Errorf("generate failed to write file: %w", err)
		}
	}

	return nil
}
